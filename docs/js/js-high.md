# 高阶JS-作用域-函数-闭包

## 1.作用域与作用域链

> 变量（函数名）定义之后  可使用范围

> 概念：标识符的有效范围

> 标识符：变量  函数名  形参  对象的属性

- 作用域分类

> 全局作用域  在所有函数外面  js的最顶层进行定义
>
> 局部作用域  在函数内部定义
>
> 块级作用域  let 和 const  加上{}

- 作用域链

> 逐级向上，就近原则

## 2.ES6函数新特性

> - 函数定义
>
>   - 声明式
>   - 表达式
>
> - 函数的参数
>
>   - 实参：调用时传入的具体值
>   - 形参：定义函数接受实参的变量
>   - 一般情况下，形参和实参要一一对应
>
> - 函数的参数列表
>
>   - 实参个数不确定的情况  没办法通过形参接收
>   - arguments  直接在函数体中使用
>     - 数据类型：伪/类数组  （有length属性 无数组的内置方法）
>
> - 函数的参数默认值
>
>   ```js
>   function sum(a,b){
>       //参数默认值设置
>       if(b==undefined){
>           b=0;
>       }
>       return a+b;
>   }
>   sum(100)
>   ```
>
> - 函数调用方式
>
>   - 直调
>   - 对调
>   - 回调
>   - 自调 递归函数  必须要有结束条件

## 3.ES6箭头函数

- 去掉function关键字，在()和{}之间加上=>
- 如果函数体只有一行代码，可以省略return关键字 省略{}
- 如果函数形参只有一个，可以省略()

！注意：箭头函数没有arguments和this指向

```js
const sum= (a,b)=>{
    return a+b;
}
```

## 4.ES6函数参数默认值

```js
function sum(a=0,b=0){
    return a+b;
}
sum(100)

const sum = (a=0,b=0) => a+b;
```

## 5.ES6参数列表rest参数

> ES6真数组的参数列表

```js
function sum(...rest){
    return rest.reduce((pre,next)=>pre+next,0);
}
```

## 6.IIFE立即执行函数

> 定义的同时立即调用
>
> 一般用于框架或js库的封装

```js
let a = 100
;(function (a){	//防止立即执行函数之前 有其他代码
    console.log(a);
})(1000)//a=1000
```

## 7.闭包ES5

> 将一个函数内的变量保护起来，不让该变量被内存释放

### 7.1闭包的体现形式

- 外部函数包含内部函数且返回内部函数

```js
function fn(){
    //处理自己的业务逻辑
    return function(){
        return '最终数据'
    }
}
//可以多次反复调用
var fn1=fn();
fn1();	//可以多次执行fn1 也就是return函数
fn1();

//多次执行fn整体
fn()();
```

- 通过IIFE形成独立作用域

```js
;(function(i){
    return '最终数据'
})(i)
```

- 函数柯里化

> 运用闭包思想 一种极简的代码设计思路

```js
const sum = a => b => c => a+b+c;
```

## 8.暂存死区

> let const